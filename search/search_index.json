{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"beancount-gains-calc","text":"<p>This is a template repository for Python projects that use uv for their dependency management.</p>"},{"location":"modules/","title":"Modules","text":"<p>Amortize expenses over a period of months.</p> <p>Calculate capital gains for UK tax purposes.</p> <p>Tag transactions based on account.</p>"},{"location":"modules/#beancount_blue.amortize.amortize","title":"<code>amortize(entries, _, config_str)</code>","text":"<p>Amortize expenses over a period of months.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>Entries</code> <p>A list of beancount entries.</p> required <code>config_str</code> <code>str</code> <p>A string containing the configuration for the plugin.</p> required <p>Returns:</p> Type Description <code>tuple[Entries, list[AmortizeError]]</code> <p>A tuple of the modified entries and a list of errors.</p> Source code in <code>beancount_blue/amortize.py</code> <pre><code>def amortize(entries: Entries, _, config_str: str) -&gt; tuple[Entries, list[AmortizeError]]:\n    \"\"\"Amortize expenses over a period of months.\n\n    Args:\n        entries: A list of beancount entries.\n        config_str: A string containing the configuration for the plugin.\n\n    Returns:\n        A tuple of the modified entries and a list of errors.\n    \"\"\"\n    config = ast.literal_eval(config_str)\n    accounts = config.get(\"accounts\", None)\n    if not accounts:\n        return entries, [AmortizeError(source=None, message=\"no accounts defined\", entry=None)]\n\n    new_entries = entries[:]\n\n    errors = []\n    for config_acct, acct_config in accounts.items():\n        if not config_acct.startswith(\"Expenses:\"):\n            raise Exception(f\"amortize requires Expenses: accounts, got {config_acct}\")  # noqa: TRY002, TRY003\n        acct = config_acct.replace(\"Expenses:\", \"Equity:Amortization:\")\n        counteraccount = config_acct\n        months = acct_config.get(\"months\", None)\n        if months is None:\n            errors.append(AmortizeError(source=None, message=f\"no months for account {config_acct}\", entry=None))\n        decimals = acct_config.get(\"decimals\", 2)\n\n        print(f\"Running amortize for {acct}, counter {counteraccount}, months {months}, decimals {decimals}\")\n\n        # Collect all of the trading histories\n        cashflow = {}\n        for _, entry in enumerate(entries):\n            if not isinstance(entry, Transaction):\n                continue\n            for _, post in enumerate(entry.postings):\n                if post.account != config_acct:\n                    continue\n                if len(entry.tags) &gt; 1:\n                    errors.append(AmortizeError(entry=entry, message=\"must be zero or one tag only\", source=None))\n                    continue\n                if not post.units or not post.units.number:\n                    errors.append(\n                        AmortizeError(entry=entry, message=\"cannot amortize a posting without units\", source=None)\n                    )\n                    continue\n                tag = next(iter(entry.tags)) if entry.tags else \"\"\n                key = (tag, post.units.currency)\n                if key not in cashflow:\n                    cashflow[key] = defaultdict(Decimal)\n                remaining_amt = -1 * post.units.number\n                for i in range(months):\n                    cashflow_amt = Decimal(round(remaining_amt / (months - i), decimals))\n                    cashflow_date = (\n                        entry.date + relativedelta.relativedelta(months=i) + relativedelta.relativedelta(day=31)\n                    )\n                    cashflow[key][cashflow_date] += cashflow_amt\n                    if i == 0:\n                        cashflow[key][cashflow_date] += post.units.number\n                    remaining_amt -= cashflow_amt\n\n        for key, amts in cashflow.items():\n            narration = \"Amortization Adjustment\"\n            if key[0]:\n                narration = narration + f\" for {key[0]}\"\n            for date, amt in amts.items():\n                new_entries.append(\n                    Transaction(\n                        date=date,\n                        meta={\"lineno\": 0},\n                        flag=FLAG_OKAY,\n                        payee=\"Amortized\",\n                        narration=narration,\n                        tags=frozenset({key[0], \"amort\"}) if key[0] else frozenset({\"amort\"}),\n                        links=frozenset(),\n                        postings=[\n                            Posting(acct, Amount(number=amt, currency=key[1]), None, None, None, {}),\n                            Posting(counteraccount, Amount(number=-1 * amt, currency=key[1]), None, None, None, {}),\n                        ],\n                    )\n                )\n\n    return new_entries, errors\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Account","title":"<code>Account</code>","text":"<p>An account that holds securities.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>class Account:\n    \"\"\"An account that holds securities.\"\"\"\n\n    def __init__(self, account: str, config: dict):\n        \"\"\"Initialize the account.\n\n        Args:\n            account: The name of the account.\n            config: The configuration for the account.\n        \"\"\"\n        self.account = account\n        self.config = config\n        self.cost_currency = None\n        self.history = {}\n        self.last_balance = {}\n\n    def process(self) -&gt; list[Adjustment]:\n        \"\"\"Process the trades in the account.\n\n        Returns:\n            A list of adjustments.\n        \"\"\"\n        adjustments = []\n\n        method = METHODS.get(self.config.get(\"method\", \"\"), None)\n        if method is None:\n            raise Exception(f\"Account {self.account} has no valid method, mustbe one of {', '.join(METHODS.keys())}\")  # noqa: TRY002, TRY003\n\n        cacct = self.config.get(\"counterAccount\", None)\n\n        # Add in counteraccount configuration\n        for trades in self.history.values():\n            adjs = method(trades)\n            adjustments.extend([a._replace(counterAccount=cacct) for a in adjs])\n\n        return adjustments\n\n    def add_posting(self, postingId: PostingID, entry: Transaction, posting: Posting) -&gt; Optional[str]:\n        \"\"\"Add a posting to the account.\n\n        Args:\n            postingId: The ID of the posting.\n            entry: The entry containing the posting.\n            posting: The posting to add.\n\n        Returns:\n            An error message if there was an error, otherwise None.\n        \"\"\"\n        # Validate the cost currency\n        # TODO: Should be indexed per posting.unit.currency\n        if posting.cost is None:\n            return f\"posting {entry.date} and {posting.account} has no cost\"\n\n        if posting.units is None or posting.units.number is None:\n            return f\"posting {entry.date} and {posting.account} has no units\"\n\n        if self.cost_currency is None:\n            self.cost_currency = posting.cost.currency\n        elif self.cost_currency != posting.cost.currency:\n            return (\n                f\"account {self.account} has inconsistent cost currencies:\"\n                + f\"{self.cost_currency} and {posting.units.currency}\"\n            )\n\n        if posting.cost.date != entry.date:\n            return f\"cost date {posting.cost.date} is different\" + f\"than transaction date {entry.date}\"\n\n        # Get the last balance\n        balance = self.last_balance.get(posting.units.currency, Decimal(0))\n\n        # Determine if realizing\n        # print(posting)\n        if (balance &gt; 0 and posting.units.number &lt; 0) or (balance &lt; 0 and posting.units.number &gt; 0):\n            realizing = True\n        else:\n            realizing = False\n\n        # TODO: Validate cost date versus transaction date\n\n        # Add the trade\n        price = posting.cost.number_per if isinstance(posting.cost, CostSpec) else posting.cost.number\n        if price is None:\n            return f\"cost {posting.cost} has no price!\"\n\n        self.history.setdefault(posting.units.currency, []).append(\n            Trade(\n                postingId=postingId,\n                date=entry.date,\n                units=posting.units.number,\n                price=price,\n                realizing=realizing,\n            )\n        )\n\n        # Update the last balance\n        self.last_balance[posting.units.currency] = balance + posting.units.number\n\n        return None\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Account.__init__","title":"<code>__init__(account, config)</code>","text":"<p>Initialize the account.</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>str</code> <p>The name of the account.</p> required <code>config</code> <code>dict</code> <p>The configuration for the account.</p> required Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>def __init__(self, account: str, config: dict):\n    \"\"\"Initialize the account.\n\n    Args:\n        account: The name of the account.\n        config: The configuration for the account.\n    \"\"\"\n    self.account = account\n    self.config = config\n    self.cost_currency = None\n    self.history = {}\n    self.last_balance = {}\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Account.add_posting","title":"<code>add_posting(postingId, entry, posting)</code>","text":"<p>Add a posting to the account.</p> <p>Parameters:</p> Name Type Description Default <code>postingId</code> <code>PostingID</code> <p>The ID of the posting.</p> required <code>entry</code> <code>Transaction</code> <p>The entry containing the posting.</p> required <code>posting</code> <code>Posting</code> <p>The posting to add.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>An error message if there was an error, otherwise None.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>def add_posting(self, postingId: PostingID, entry: Transaction, posting: Posting) -&gt; Optional[str]:\n    \"\"\"Add a posting to the account.\n\n    Args:\n        postingId: The ID of the posting.\n        entry: The entry containing the posting.\n        posting: The posting to add.\n\n    Returns:\n        An error message if there was an error, otherwise None.\n    \"\"\"\n    # Validate the cost currency\n    # TODO: Should be indexed per posting.unit.currency\n    if posting.cost is None:\n        return f\"posting {entry.date} and {posting.account} has no cost\"\n\n    if posting.units is None or posting.units.number is None:\n        return f\"posting {entry.date} and {posting.account} has no units\"\n\n    if self.cost_currency is None:\n        self.cost_currency = posting.cost.currency\n    elif self.cost_currency != posting.cost.currency:\n        return (\n            f\"account {self.account} has inconsistent cost currencies:\"\n            + f\"{self.cost_currency} and {posting.units.currency}\"\n        )\n\n    if posting.cost.date != entry.date:\n        return f\"cost date {posting.cost.date} is different\" + f\"than transaction date {entry.date}\"\n\n    # Get the last balance\n    balance = self.last_balance.get(posting.units.currency, Decimal(0))\n\n    # Determine if realizing\n    # print(posting)\n    if (balance &gt; 0 and posting.units.number &lt; 0) or (balance &lt; 0 and posting.units.number &gt; 0):\n        realizing = True\n    else:\n        realizing = False\n\n    # TODO: Validate cost date versus transaction date\n\n    # Add the trade\n    price = posting.cost.number_per if isinstance(posting.cost, CostSpec) else posting.cost.number\n    if price is None:\n        return f\"cost {posting.cost} has no price!\"\n\n    self.history.setdefault(posting.units.currency, []).append(\n        Trade(\n            postingId=postingId,\n            date=entry.date,\n            units=posting.units.number,\n            price=price,\n            realizing=realizing,\n        )\n    )\n\n    # Update the last balance\n    self.last_balance[posting.units.currency] = balance + posting.units.number\n\n    return None\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Account.process","title":"<code>process()</code>","text":"<p>Process the trades in the account.</p> <p>Returns:</p> Type Description <code>list[Adjustment]</code> <p>A list of adjustments.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>def process(self) -&gt; list[Adjustment]:\n    \"\"\"Process the trades in the account.\n\n    Returns:\n        A list of adjustments.\n    \"\"\"\n    adjustments = []\n\n    method = METHODS.get(self.config.get(\"method\", \"\"), None)\n    if method is None:\n        raise Exception(f\"Account {self.account} has no valid method, mustbe one of {', '.join(METHODS.keys())}\")  # noqa: TRY002, TRY003\n\n    cacct = self.config.get(\"counterAccount\", None)\n\n    # Add in counteraccount configuration\n    for trades in self.history.values():\n        adjs = method(trades)\n        adjustments.extend([a._replace(counterAccount=cacct) for a in adjs])\n\n    return adjustments\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Adjustment","title":"<code>Adjustment</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>An adjustment to a trade.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>class Adjustment(NamedTuple):\n    \"\"\"An adjustment to a trade.\"\"\"\n\n    postingId: PostingID\n    price: Decimal\n    counterAmount: Decimal\n    counterAccount: Optional[str]\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.GainsCalculatorError","title":"<code>GainsCalculatorError</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>An error that occurred during capital gains calculation.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>class GainsCalculatorError(NamedTuple):\n    \"\"\"An error that occurred during capital gains calculation.\"\"\"\n\n    source: Meta\n    message: str\n    entry: object\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.Trade","title":"<code>Trade</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A trade in a security.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>class Trade(NamedTuple):\n    \"\"\"A trade in a security.\"\"\"\n\n    postingId: PostingID\n    date: datetime.date\n    units: Decimal\n    price: Decimal\n    realizing: bool\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.calc_gains","title":"<code>calc_gains(entries, _, config_str)</code>","text":"<p>Calculate capital gains for UK tax purposes.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>Entries</code> <p>A list of beancount entries.</p> required <code>config_str</code> <code>str</code> <p>A string containing the configuration for the plugin.</p> required <p>Returns:</p> Type Description <code>tuple[list[Directive], list[GainsCalculatorError]]</code> <p>A tuple of the modified entries and a list of errors.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>def calc_gains(entries: Entries, _, config_str: str) -&gt; tuple[list[Directive], list[GainsCalculatorError]]:\n    \"\"\"Calculate capital gains for UK tax purposes.\n\n    Args:\n        entries: A list of beancount entries.\n        config_str: A string containing the configuration for the plugin.\n\n    Returns:\n        A tuple of the modified entries and a list of errors.\n    \"\"\"\n    accounts = {}\n\n    config = ast.literal_eval(config_str)\n    for acct, acct_config in config.get(\"accounts\", {}).items():\n        accounts[acct] = Account(acct, acct_config)\n\n    errors = []\n\n    # Collect all of the trading histories\n    for transId, entry in enumerate(entries):\n        if not isinstance(entry, Transaction):\n            continue\n        for postId, post in enumerate(entry.postings):\n            if post.account not in accounts:\n                continue\n            if not post.cost and not post.price:\n                continue\n            if not post.cost:\n                errors.append(\"missing cost?!?\")\n                continue\n            accounts[post.account].add_posting((transId, postId), entry, post)\n\n    # Collect adjustments for accounts\n    adjs = []\n    for account in accounts.values():\n        adjs.extend(account.process())\n\n    # Apply adjustments to the entries\n    new_entries = entries.copy()\n    errors = []\n    for adj in adjs:\n        trans = new_entries[adj.postingId[0]]\n\n        # If there is no counterAccount, we need to report an error\n        if adj.counterAccount is None:\n            errors.append(\n                GainsCalculatorError(trans.meta, f\"Calculated cost price is {adj.price}, not matching\", trans)\n            )\n            continue\n\n        # Adjust the price\n        trans.postings[adj.postingId[1]] = trans.postings[adj.postingId[1]]._replace(\n            cost=trans.postings[adj.postingId[1]].cost._replace(\n                number=adj.price,\n            )\n        )\n\n        # Create the adjustment posting\n        trans.postings.append(\n            Posting(\n                account=adj.counterAccount,\n                units=Amount(number=adj.counterAmount, currency=trans.postings[adj.postingId[1]].cost.currency),\n                cost=None,\n                price=None,\n                flag=None,\n                meta={\"note\": \"adjusted\"},\n            )\n        )\n\n    return new_entries, errors\n</code></pre>"},{"location":"modules/#beancount_blue.calc_uk_gains.cost_avg","title":"<code>cost_avg(trades)</code>","text":"<p>Calculate the average cost of a list of trades.</p> <p>Parameters:</p> Name Type Description Default <code>trades</code> <code>list[Trade]</code> <p>A list of trades.</p> required <p>Returns:</p> Type Description <code>list[Adjustment]</code> <p>A list of adjustments.</p> Source code in <code>beancount_blue/calc_uk_gains.py</code> <pre><code>def cost_avg(trades: list[Trade]) -&gt; list[Adjustment]:\n    \"\"\"Calculate the average cost of a list of trades.\n\n    Args:\n        trades: A list of trades.\n\n    Returns:\n        A list of adjustments.\n    \"\"\"\n    adjs = []\n    total_units = Decimal(0)\n    total_cost = Decimal(0)\n    for _, trade in enumerate(trades):\n        if trade.realizing:\n            avg_cost_price = total_cost / total_units\n            if trade.price != avg_cost_price:\n                adjs.append(\n                    Adjustment(\n                        postingId=trade.postingId,\n                        price=total_cost / total_units,\n                        counterAmount=((trade.price * trade.units) - (avg_cost_price * trade.units)),\n                        counterAccount=None,\n                    )\n                )\n            total_cost += trade.units * avg_cost_price\n        else:\n            total_cost += trade.units * trade.price\n        total_units += trade.units\n    return adjs\n</code></pre>"},{"location":"modules/#beancount_blue.tag.tag","title":"<code>tag(entries, _, config_str)</code>","text":"<p>Tag transactions based on account.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>Entries</code> <p>A list of beancount entries.</p> required <code>config_str</code> <code>str</code> <p>A string containing the configuration for the plugin.</p> required <p>Returns:</p> Type Description <code>tuple[Entries, list[Any]]</code> <p>A tuple of the modified entries and a list of errors.</p> Source code in <code>beancount_blue/tag.py</code> <pre><code>def tag(entries: Entries, _, config_str: str) -&gt; tuple[Entries, list[Any]]:\n    \"\"\"Tag transactions based on account.\n\n    Args:\n        entries: A list of beancount entries.\n        config_str: A string containing the configuration for the plugin.\n\n    Returns:\n        A tuple of the modified entries and a list of errors.\n    \"\"\"\n    config = ast.literal_eval(config_str)\n    accounts = config.get(\"accounts\", None)\n    if not accounts:\n        return entries, [\"no accounts defined\"]\n\n    new_entries = entries[:]\n\n    errors = []\n    for acct, tag in accounts.items():\n        print(f\"Running tag for {acct}, tag {tag}\")\n\n        for transId, entry in enumerate(new_entries):\n            if not isinstance(entry, Transaction):\n                continue\n            if all(post.account != acct for post in entry.postings):\n                continue\n            new_entries[transId] = entry._replace(tags=frozenset(set(entry.tags).union([tag])))\n\n    return new_entries, errors\n</code></pre>"}]}